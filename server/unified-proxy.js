/**
 * AIÊéÉÈô§„Ç¢„Éâ„Éê„Ç§„Ç∂„Éº Áµ±Âêà„Éó„É≠„Ç≠„Ç∑„Çµ„Éº„Éê„Éº
 * CX Mainte ¬© 2025
 * 
 * Ê©üËÉΩÔºö
 * - Gemini AIÁîªÂÉèËß£Êûê„Éó„É≠„Ç≠„Ç∑
 * - Amazon PA-APIÂïÜÂìÅÂèñÂæó„Éó„É≠„Ç≠„Ç∑
 * - „Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØÁµ±ÂêàÔºà„É¶„Éº„Ç∂„Éº„ÅØAPI„Ç≠„Éº‰∏çË¶ÅÔºâ
 * - ÂèéÁõäÂåñÔºöAmazon„Ç¢„ÇΩ„Ç∑„Ç®„Ç§„ÉàÊâãÊï∞Êñô
 */

const express = require('express');
const cors = require('cors');
const crypto = require('crypto');
const https = require('https');
const fetch = require('node-fetch'); // npm install node-fetch „ÅåÂøÖË¶Å
const multer = require('multer'); // npm install multer „ÅåÂøÖË¶Å

// Express„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆÂàùÊúüÂåñ
const app = express();
const PORT = process.env.PORT || 3001;

// „Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâË®≠ÂÆö
const upload = multer({
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MBÂà∂Èôê
    fileFilter: (req, file, cb) => {
        const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
        cb(null, allowedTypes.includes(file.mimetype));
    }
});

// CORSË®≠ÂÆöÔºàÊú¨Áï™Áí∞Â¢É„Åß„ÅØÈÅ©Âàá„Å™„Ç™„É™„Ç∏„É≥„ÇíÊåáÂÆöÔºâ
app.use(cors({
    origin: process.env.ALLOWED_ORIGINS ? 
        process.env.ALLOWED_ORIGINS.split(',') : 
        [
            'https://nakadouzonokouji.github.io',
            'http://localhost:3000', 
            'http://127.0.0.1:5500'
        ],
    methods: ['GET', 'POST'],
    allowedHeaders: ['Content-Type', 'Authorization']
}));

// JSON„Éë„Éº„Çµ„Éº
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Áí∞Â¢ÉÂ§âÊï∞„ÅÆÊ§úË®º
const requiredEnvVars = [
    'PAAPI_ACCESS_KEY', 
    'PAAPI_SECRET_KEY', 
    'PAAPI_ASSOC_TAG',
    'GEMINI_API_KEY'
];

const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);

if (missingVars.length > 0) {
    console.error('‚ùå ÂøÖË¶Å„Å™Áí∞Â¢ÉÂ§âÊï∞„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì:', missingVars);
    console.error('üí° .env„Éï„Ç°„Ç§„É´„Åæ„Åü„ÅØÁí∞Â¢ÉÂ§âÊï∞„Å´‰ª•‰∏ã„ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ:');
    missingVars.forEach(varName => {
        console.error(`   ${varName}=your_value_here`);
    });
    process.exit(1);
}

// APIË®≠ÂÆö
const API_CONFIG = {
    // Amazon PA-APIË®≠ÂÆö
    amazon: {
        accessKey: process.env.PAAPI_ACCESS_KEY,
        secretKey: process.env.PAAPI_SECRET_KEY,
        associateTag: process.env.PAAPI_ASSOC_TAG,
        region: 'us-west-2',
        host: 'webservices.amazon.co.jp',
        uri: '/paapi5/getitems',
        marketplace: 'www.amazon.co.jp'
    },
    // Gemini AIË®≠ÂÆö
    gemini: {
        apiKey: process.env.GEMINI_API_KEY,
        model: 'gemini-1.5-flash',
        endpoint: 'https://generativelanguage.googleapis.com/v1beta/models'
    }
};

// „É™„ÇØ„Ç®„Çπ„ÉàÁµ±Ë®à
const stats = {
    startTime: Date.now(),
    requests: {
        total: 0,
        gemini: 0,
        amazon: 0,
        errors: 0
    }
};

/**
 * AWSÁΩ≤ÂêçV4„ÅÆÁîüÊàêÔºàAmazon PA-APIÁî®Ôºâ
 */
function createAWSSignatureV4(request, accessKey, secretKey) {
    const now = new Date();
    const amzDate = now.toISOString().replace(/[:\\-]|\\.\\d{3}/g, '');
    const dateStamp = amzDate.substr(0, 8);
    
    // „Ç´„Éé„Éã„Ç´„É´„É™„ÇØ„Ç®„Çπ„Éà„ÅÆ‰ΩúÊàê
    const canonicalHeaders = Object.keys(request.headers)
        .sort()
        .map(key => `${key.toLowerCase()}:${request.headers[key]}\\n`)
        .join('');
    
    const signedHeaders = Object.keys(request.headers)
        .sort()
        .map(key => key.toLowerCase())
        .join(';');
    
    const payloadHash = crypto
        .createHash('sha256')
        .update(request.body || '', 'utf8')
        .digest('hex');
    
    const canonicalRequest = [
        request.method,
        request.uri,
        '',
        canonicalHeaders,
        signedHeaders,
        payloadHash
    ].join('\\n');
    
    // ÁΩ≤ÂêçÊñáÂ≠óÂàó„ÅÆ‰ΩúÊàê
    const algorithm = 'AWS4-HMAC-SHA256';
    const credentialScope = `${dateStamp}/${API_CONFIG.amazon.region}/ProductAdvertisingAPI/aws4_request`;
    const stringToSign = [
        algorithm,
        amzDate,
        credentialScope,
        crypto.createHash('sha256').update(canonicalRequest, 'utf8').digest('hex')
    ].join('\\n');
    
    // ÁΩ≤Âêç„Ç≠„Éº„ÅÆË®àÁÆó
    const kDate = crypto.createHmac('sha256', `AWS4${secretKey}`).update(dateStamp).digest();
    const kRegion = crypto.createHmac('sha256', kDate).update(API_CONFIG.amazon.region).digest();
    const kService = crypto.createHmac('sha256', kRegion).update('ProductAdvertisingAPI').digest();
    const kSigning = crypto.createHmac('sha256', kService).update('aws4_request').digest();
    
    // ÁΩ≤Âêç„ÅÆË®àÁÆó
    const signature = crypto.createHmac('sha256', kSigning).update(stringToSign).digest('hex');
    
    // Ë™çË®º„Éò„ÉÉ„ÉÄ„Éº„ÅÆÁµÑ„ÅøÁ´ã„Å¶
    const authorizationHeader = `${algorithm} Credential=${accessKey}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;
    
    return {
        'Authorization': authorizationHeader,
        'X-Amz-Date': amzDate,
        'X-Amz-Target': 'com.amazon.paapi5.v1.ProductAdvertisingAPIv1.GetItems'
    };
}

/**
 * Gemini AIÁîªÂÉèËß£Êûê
 */
async function analyzeImageWithGemini(imageBase64, prompt) {
    try {
        console.log('ü§ñ Gemini AIÁîªÂÉèËß£ÊûêÈñãÂßã');
        
        const requestBody = {
            contents: [{
                parts: [
                    { text: prompt },
                    {
                        inline_data: {
                            mime_type: 'image/jpeg',
                            data: imageBase64
                        }
                    }
                ]
            }],
            generationConfig: {
                temperature: 0.7,
                maxOutputTokens: 1000
            }
        };

        const response = await fetch(
            `${API_CONFIG.gemini.endpoint}/${API_CONFIG.gemini.model}:generateContent?key=${API_CONFIG.gemini.apiKey}`,
            {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            }
        );

        if (!response.ok) {
            throw new Error(`Gemini API Error: ${response.status}`);
        }

        const data = await response.json();
        const analysisText = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!analysisText) {
            throw new Error('Gemini API„Åã„Çâ„ÅÆÂøúÁ≠î„Åå‰∏çÊ≠£„Åß„Åô');
        }

        console.log('‚úÖ Gemini AIÁîªÂÉèËß£ÊûêÂÆå‰∫Ü');
        stats.requests.gemini++;
        
        return analysisText;
        
    } catch (error) {
        console.error('üí• Gemini AIËß£Êûê„Ç®„É©„Éº:', error.message);
        stats.requests.errors++;
        throw error;
    }
}

/**
 * Amazon PA-APIÂïÜÂìÅÂèñÂæó
 */
async function fetchProductFromAmazon(asin) {
    return new Promise((resolve, reject) => {
        console.log(`üõí AmazonÂïÜÂìÅÂèñÂæóÈñãÂßã: ${asin}`);
        
        const requestBody = {
            ItemIds: [asin],
            Resources: [
                'ItemInfo.Title',
                'Offers.Listings.Price',
                'Images.Primary.Large',
                'CustomerReviews.StarRating',
                'CustomerReviews.Count',
                'Offers.Listings.Availability.Message'
            ],
            PartnerTag: API_CONFIG.amazon.associateTag,
            PartnerType: 'Associates',
            Marketplace: API_CONFIG.amazon.marketplace
        };
        
        const bodyData = JSON.stringify(requestBody);
        
        const headers = {
            'Content-Type': 'application/json; charset=utf-8',
            'Content-Length': Buffer.byteLength(bodyData),
            'Host': API_CONFIG.amazon.host,
            'X-Amz-Target': 'com.amazon.paapi5.v1.ProductAdvertisingAPIv1.GetItems'
        };
        
        const request = {
            method: 'POST',
            uri: API_CONFIG.amazon.uri,
            headers: headers,
            body: bodyData
        };
        
        const signedHeaders = createAWSSignatureV4(request, API_CONFIG.amazon.accessKey, API_CONFIG.amazon.secretKey);
        Object.assign(headers, signedHeaders);
        
        const options = {
            hostname: API_CONFIG.amazon.host,
            port: 443,
            path: API_CONFIG.amazon.uri,
            method: 'POST',
            headers: headers,
            timeout: 15000
        };
        
        const req = https.request(options, (res) => {
            let data = '';
            
            res.on('data', (chunk) => {
                data += chunk;
            });
            
            res.on('end', () => {
                try {
                    const responseData = JSON.parse(data);
                    
                    if (res.statusCode !== 200) {
                        console.error(`‚ùå Amazon PA-API„Ç®„É©„Éº (${res.statusCode}):`, responseData);
                        return reject(new Error(`Amazon PA-API request failed: ${res.statusCode}`));
                    }
                    
                    console.log(`‚úÖ AmazonÂïÜÂìÅÂèñÂæóÊàêÂäü: ${asin}`);
                    stats.requests.amazon++;
                    resolve(responseData);
                    
                } catch (error) {
                    console.error(`üí• Amazon „É¨„Çπ„Éù„É≥„ÇπËß£Êûê„Ç®„É©„Éº:`, error.message);
                    stats.requests.errors++;
                    reject(new Error('Failed to parse Amazon PA-API response'));
                }
            });
        });
        
        req.on('error', (error) => {
            console.error(`üî• Amazon PA-API„É™„ÇØ„Ç®„Çπ„Éà„Ç®„É©„Éº:`, error.message);
            stats.requests.errors++;
            reject(error);
        });
        
        req.on('timeout', () => {
            console.error(`‚è∞ Amazon PA-API„Çø„Ç§„É†„Ç¢„Ç¶„Éà: ${asin}`);
            req.destroy();
            stats.requests.errors++;
            reject(new Error('Amazon PA-API request timeout'));
        });
        
        req.write(bodyData);
        req.end();
    });
}

/**
 * AmazonÂïÜÂìÅ„Éá„Éº„Çø„ÅÆÊ®ôÊ∫ñÂåñ
 */
function transformAmazonProduct(papiResponse, asin) {
    try {
        const item = papiResponse.ItemsResult?.Items?.[0];
        
        if (!item) {
            return createFallbackProduct(asin);
        }
        
        const title = item.ItemInfo?.Title?.DisplayValue || `AmazonÂïÜÂìÅ ${asin}`;
        
        let price = '‰æ°Ê†º‰∏çÊòé';
        const offer = item.Offers?.Listings?.[0];
        if (offer?.Price?.DisplayAmount) {
            price = offer.Price.DisplayAmount;
        }
        
        let image = `https://images-na.ssl-images-amazon.com/images/P/${asin}.01.LZZZZZZZ.jpg`;
        if (item.Images?.Primary?.Large?.URL) {
            image = item.Images.Primary.Large.URL;
        }
        
        const urlWithTag = item.DetailPageURL || `https://www.amazon.co.jp/dp/${asin}?tag=${API_CONFIG.amazon.associateTag}`;
        
        let rating = 0;
        let reviews = 0;
        if (item.CustomerReviews) {
            rating = parseFloat(item.CustomerReviews.StarRating?.DisplayValue) || 0;
            reviews = parseInt(item.CustomerReviews.Count?.DisplayValue) || 0;
        }
        
        let availability = 'Âú®Â∫´Áä∂Ê≥Å‰∏çÊòé';
        if (offer?.Availability?.Message) {
            availability = offer.Availability.Message;
        }
        
        return {
            title,
            price,
            image,
            urlWithTag,
            rating,
            reviews,
            availability,
            asin,
            source: 'amazon-paapi'
        };
        
    } catch (error) {
        console.error(`üí• AmazonÂïÜÂìÅ„Éá„Éº„ÇøÂ§âÊèõ„Ç®„É©„Éº:`, error.message);
        return createFallbackProduct(asin);
    }
}

/**
 * „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂïÜÂìÅ„Éá„Éº„Çø
 */
function createFallbackProduct(asin) {
    return {
        title: `AmazonÂïÜÂìÅ ${asin}`,
        price: '‰æ°Ê†º„ÇíÁ¢∫Ë™ç',
        image: `https://images-na.ssl-images-amazon.com/images/P/${asin}.01.LZZZZZZZ.jpg`,
        urlWithTag: `https://www.amazon.co.jp/dp/${asin}?tag=${API_CONFIG.amazon.associateTag}`,
        rating: 0,
        reviews: 0,
        availability: 'Amazon„ÅßÁ¢∫Ë™ç',
        asin,
        source: 'fallback'
    };
}

// ===== API „Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà =====

/**
 * POST /api/analyze - ÁîªÂÉèËß£ÊûêÔºãÂïÜÂìÅÊé®Ëñ¶„ÅÆÁµ±Âêà„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
 */
app.post('/api/analyze', upload.single('image'), async (req, res) => {
    const startTime = Date.now();
    stats.requests.total++;
    
    try {
        console.log('üöÄ Áµ±ÂêàËß£Êûê„É™„ÇØ„Ç®„Çπ„ÉàÂèó‰ø°');
        
        // ÁîªÂÉè„Éá„Éº„Çø„ÅÆÂèñÂæó
        let imageBase64;
        if (req.file) {
            imageBase64 = req.file.buffer.toString('base64');
        } else if (req.body.image) {
            imageBase64 = req.body.image.replace(/^data:image\/[a-z]+;base64,/, '');
        } else {
            return res.status(400).json({
                error: 'ÁîªÂÉè„Éá„Éº„Çø„ÅåÂøÖË¶Å„Åß„Åô',
                message: 'image „Éï„Ç°„Ç§„É´„Åæ„Åü„ÅØbase64„Éá„Éº„Çø„ÇíÈÄÅ‰ø°„Åó„Å¶„Åè„Å†„Åï„ÅÑ'
            });
        }
        
        // Â†¥ÊâÄ„ÉªÊùêË≥™ÊÉÖÂ†±„ÅÆÂèñÂæó
        const location = req.body.location || '„Åù„ÅÆ‰ªñ';
        const surface = req.body.surface || '„Åù„ÅÆ‰ªñ';
        
        // Gemini AI„ÅßÁîªÂÉèËß£Êûê
        const analysisPrompt = `
„Åì„ÅÆÊéÉÈô§„ÅåÂøÖË¶Å„Å™ÁîªÂÉè„ÇíÂàÜÊûê„Åó„Å¶„ÄÅ‰ª•‰∏ã„ÅÆÊÉÖÂ†±„ÇíJSONÂΩ¢Âºè„ÅßËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö

{
  "dirtType": "Ê±ö„Çå„ÅÆÁ®ÆÈ°ûÔºàÊ≤πÊ±ö„Çå„ÄÅ„Ç´„Éì„ÄÅÊ∞¥Âû¢„ÄÅ„Éõ„Ç≥„É™„ÄÅÈªÑ„Å∞„Åø„ÄÅÁÑ¶„Åí‰ªò„Åç„ÄÅ„Åù„ÅÆ‰ªñÔºâ",
  "severity": "Ê±ö„Çå„ÅÆÁ®ãÂ∫¶ÔºàËªΩÂ∫¶„ÄÅ‰∏≠Á®ãÂ∫¶„ÄÅÈáçÂ∫¶Ôºâ",
  "surface": "Ë°®Èù¢„ÅÆÊùêË≥™Ôºà${surface}Ôºâ",
  "location": "Â†¥ÊâÄÔºà${location}Ôºâ",
  "confidence": "Âà§ÂÆö„ÅÆ‰ø°È†ºÂ∫¶Ôºà0-100Ôºâ",
  "recommendedMethod": "Êé®Â•®ÊéÉÈô§ÊñπÊ≥ï„ÅÆÁ∞°ÊΩî„Å™Ë™¨Êòé",
  "productCategories": ["Êé®Â•®ÂïÜÂìÅ„Ç´„ÉÜ„Ç¥„É™1", "Êé®Â•®ÂïÜÂìÅ„Ç´„ÉÜ„Ç¥„É™2"]
}

ÁîªÂÉè„Åã„ÇâÂà§Êñ≠„Åß„Åç„ÇãÊÉÖÂ†±„ÅÆ„Åø„ÇíÂõûÁ≠î„Åó„ÄÅJSONÂΩ¢Âºè‰ª•Â§ñ„ÅØÂê´„ÇÅ„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ
`;
        
        const analysisResult = await analyzeImageWithGemini(imageBase64, analysisPrompt);
        
        // JSONËß£Êûê
        let analysisData;
        try {
            const jsonMatch = analysisResult.match(/\\{[\\s\\S]*\\}/);
            if (jsonMatch) {
                analysisData = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('JSONÂΩ¢Âºè„ÅÆÂøúÁ≠î„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
            }
        } catch (parseError) {
            console.warn('‚ö†Ô∏è JSONËß£ÊûêÂ§±Êïó„ÄÅ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ‰ΩøÁî®');
            analysisData = {
                dirtType: '„Åù„ÅÆ‰ªñ„ÅÆÊ±ö„Çå',
                severity: '‰∏≠Á®ãÂ∫¶',
                surface: surface,
                location: location,
                confidence: 70,
                recommendedMethod: 'ÈÅ©Âàá„Å™ÊéÉÈô§Áî®ÂìÅ„ÅßÊ∏ÖÊã≠„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
                productCategories: ['Â§öÁõÆÁöÑÊ¥óÂâ§', 'ÊéÉÈô§Áî®ÂÖ∑']
            };
        }
        
        // ÂïÜÂìÅÊé®Ëñ¶ÔºàÁ∞°ÊòìÁâà - ÂÆüÈöõ„ÅØÂïÜÂìÅ„Éá„Éº„Çø„Éô„Éº„Çπ„Å®ÈÄ£Êê∫Ôºâ
        const recommendedProducts = await getRecommendedProducts(analysisData);
        
        // Âá¶ÁêÜÊôÇÈñì„ÇíË®àÁÆó
        const processingTime = Date.now() - startTime;
        
        // Áµ±Âêà„É¨„Çπ„Éù„É≥„Çπ
        res.json({
            success: true,
            analysis: analysisData,
            products: recommendedProducts,
            meta: {
                processingTime: `${processingTime}ms`,
                requestId: crypto.randomUUID(),
                timestamp: new Date().toISOString(),
                apiVersion: '1.0'
            }
        });
        
        console.log(`‚úÖ Áµ±ÂêàËß£ÊûêÂÆå‰∫Ü (${processingTime}ms)`);
        
    } catch (error) {
        console.error(`üí• Áµ±ÂêàËß£Êûê„Ç®„É©„Éº: ${error.message}`);
        stats.requests.errors++;
        
        const processingTime = Date.now() - startTime;
        
        res.status(500).json({
            success: false,
            error: {
                message: 'ÁîªÂÉèËß£Êûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü',
                details: error.message
            },
            meta: {
                processingTime: `${processingTime}ms`,
                requestId: crypto.randomUUID(),
                timestamp: new Date().toISOString()
            }
        });
    }
});

/**
 * ÂïÜÂìÅÊé®Ëñ¶„É≠„Ç∏„ÉÉ„ÇØÔºàÁ∞°ÊòìÁâàÔºâ
 */
async function getRecommendedProducts(analysisData) {
    // Ê±ö„Çå„Çø„Ç§„Éó„Å´Âü∫„Å•„ÅèÊé®Â•®ASINÔºàÂÆüÈöõ„ÅÆÂïÜÂìÅ„Éá„Éº„ÇøÔºâ
    const productMapping = {
        'Ê≤πÊ±ö„Çå': ['B000TGNG0W', 'B001234567'], // „Éû„Ç∏„ÉÉ„ÇØ„É™„É≥„Å™„Å©
        '„Ç´„Éì': ['B002345678', 'B003456789'],   // „Ç´„Éì„Ç≠„É©„Éº„Å™„Å©
        'Ê∞¥Âû¢': ['B004567890', 'B005678901'],   // „ÇØ„Ç®„É≥ÈÖ∏Á≥ª„Å™„Å©
        '„Éõ„Ç≥„É™': ['B006789012', 'B007890123'], // ÊéÉÈô§Ê©ü„ÄÅ„ÉØ„Ç§„Éë„Éº„Å™„Å©
        'ÈªÑ„Å∞„Åø': ['B008901234', 'B009012345']  // ÊºÇÁôΩÂâ§„Å™„Å©
    };
    
    const asins = productMapping[analysisData.dirtType] || productMapping['Ê≤πÊ±ö„Çå'];
    const products = [];
    
    for (const asin of asins.slice(0, 3)) { // ÊúÄÂ§ß3ÂïÜÂìÅ
        try {
            const amazonData = await fetchProductFromAmazon(asin);
            const product = transformAmazonProduct(amazonData, asin);
            products.push(product);
        } catch (error) {
            console.warn(`‚ö†Ô∏è ÂïÜÂìÅÂèñÂæóÂ§±Êïó ${asin}: ${error.message}`);
            products.push(createFallbackProduct(asin));
        }
    }
    
    return products;
}

/**
 * GET /api/product/:asin - ÂÄãÂà•ÂïÜÂìÅÊÉÖÂ†±ÂèñÂæó
 */
app.get('/api/product/:asin', async (req, res) => {
    const startTime = Date.now();
    const asin = req.params.asin;
    stats.requests.total++;
    
    console.log(`üõí ÂïÜÂìÅÊÉÖÂ†±„É™„ÇØ„Ç®„Çπ„Éà: ${asin}`);
    
    try {
        const amazonData = await fetchProductFromAmazon(asin);
        const product = transformAmazonProduct(amazonData, asin);
        
        const processingTime = Date.now() - startTime;
        
        res.json({
            success: true,
            product: product,
            meta: {
                processingTime: `${processingTime}ms`,
                requestId: crypto.randomUUID(),
                timestamp: new Date().toISOString()
            }
        });
        
    } catch (error) {
        console.error(`üí• ÂïÜÂìÅÂèñÂæó„Ç®„É©„Éº: ${error.message}`);
        stats.requests.errors++;
        
        const fallbackProduct = createFallbackProduct(asin);
        const processingTime = Date.now() - startTime;
        
        res.json({
            success: false,
            product: fallbackProduct,
            error: {
                message: 'ÂïÜÂìÅÊÉÖÂ†±„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü',
                details: error.message,
                fallback: true
            },
            meta: {
                processingTime: `${processingTime}ms`,
                requestId: crypto.randomUUID(),
                timestamp: new Date().toISOString()
            }
        });
    }
});

/**
 * GET /api/health - „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ
 */
app.get('/api/health', (req, res) => {
    const uptime = Date.now() - stats.startTime;
    
    res.json({
        status: 'healthy',
        uptime: uptime,
        stats: stats.requests,
        timestamp: new Date().toISOString(),
        version: '1.0.0',
        services: {
            gemini: !!API_CONFIG.gemini.apiKey,
            amazon: !!API_CONFIG.amazon.accessKey
        }
    });
});

/**
 * GET /api/stats - „Ç∑„Çπ„ÉÜ„É†Áµ±Ë®à
 */
app.get('/api/stats', (req, res) => {
    const uptime = Date.now() - stats.startTime;
    const successRate = stats.requests.total > 0 ? 
        Math.round(((stats.requests.total - stats.requests.errors) / stats.requests.total) * 100) : 100;
    
    res.json({
        uptime: Math.floor(uptime / 1000), // Áßí
        requests: stats.requests,
        successRate: successRate,
        averageResponseTime: 'ÈÅ©Áî®Â§ñ', // ‰ªäÂæåÂÆüË£Ö
        lastUpdated: new Date().toISOString()
    });
});

// „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Éü„Éâ„É´„Ç¶„Çß„Ç¢
app.use((error, req, res, next) => {
    console.error('üí• ‰∫àÊúü„Åó„Å™„ÅÑ„Ç®„É©„Éº:', error);
    stats.requests.errors++;
    
    res.status(500).json({
        error: 'Internal Server Error',
        message: '‰∫àÊúü„Åó„Å™„ÅÑ„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü',
        timestamp: new Date().toISOString()
    });
});

// 404„Éè„É≥„Éâ„É©„Éº
app.use((req, res) => {
    res.status(404).json({
        error: 'Not Found',
        message: '„É™„ÇØ„Ç®„Çπ„Éà„Åï„Çå„Åü„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì',
        availableEndpoints: [
            'POST /api/analyze',
            'GET /api/product/:asin',
            'GET /api/health',
            'GET /api/stats'
        ]
    });
});

// „Çµ„Éº„Éê„ÉºËµ∑Âãï
app.listen(PORT, () => {
    console.log('\\nüöÄ AIÊéÉÈô§„Ç¢„Éâ„Éê„Ç§„Ç∂„ÉºÁµ±Âêà„Éó„É≠„Ç≠„Ç∑„Çµ„Éº„Éê„ÉºËµ∑ÂãïÂÆå‰∫Ü');
    console.log(`üì° „Éù„Éº„Éà: ${PORT}`);
    console.log(`ü§ñ Gemini AI: ${API_CONFIG.gemini.apiKey ? 'Ë®≠ÂÆöÊ∏à„Åø' : 'Êú™Ë®≠ÂÆö'}`);
    console.log(`üõí Amazon PA-API: ${API_CONFIG.amazon.accessKey ? 'Ë®≠ÂÆöÊ∏à„Åø' : 'Êú™Ë®≠ÂÆö'}`);
    console.log(`üîë „Ç¢„ÇΩ„Ç∑„Ç®„Ç§„Éà„Çø„Ç∞: ${API_CONFIG.amazon.associateTag}`);
    console.log(`‚öôÔ∏è  Áí∞Â¢É: ${process.env.NODE_ENV || 'development'}`);
    console.log('\\nüí° Âà©Áî®ÂèØËÉΩ„Å™„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà:');
    console.log(`   POST http://localhost:${PORT}/api/analyze`);
    console.log(`   GET  http://localhost:${PORT}/api/product/:asin`);
    console.log(`   GET  http://localhost:${PORT}/api/health`);
    console.log(`   GET  http://localhost:${PORT}/api/stats`);
    console.log('\\nüéØ „Éì„Ç∏„Éç„Çπ„É¢„Éá„É´: AmazonÂèéÁõäÂåñÂØæÂøú');
    console.log('');
});

// „Ç∞„É¨„Éº„Çπ„Éï„É´„Ç∑„É£„ÉÉ„Éà„ÉÄ„Ç¶„É≥
process.on('SIGTERM', () => {
    console.log('üõë SIGTERMÂèó‰ø° - „Çµ„Éº„Éê„Éº„Çí„Ç∑„É£„ÉÉ„Éà„ÉÄ„Ç¶„É≥„Åó„Åæ„Åô');
    process.exit(0);
});

process.on('SIGINT', () => {
    console.log('\\nüõë SIGINTÂèó‰ø° - „Çµ„Éº„Éê„Éº„Çí„Ç∑„É£„ÉÉ„Éà„ÉÄ„Ç¶„É≥„Åó„Åæ„Åô');
    process.exit(0);
});

module.exports = app;